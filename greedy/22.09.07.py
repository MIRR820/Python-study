# 1. 1이 될때까지

# 입력 조건
# 첫째 줄에 N(1 <= N <= 1000,000)과 K(2 <= K <= 1000,000)가
# 공백을 기준으로 하여 각각 자연수로 주어집니다.

# 출력 조건
# 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값을 출력합니다.

N, K = map(int, (input().split()))
sum = 0
while N >= K:   #N이 K보다 크거나 같으면 최대한 나눈다.
    while N % K != 0:   #36 9   4 9
        N -= 1
        sum += 1
    N //= K
    sum += 1

while N != 1:    #N이 K보다 작으면 빼기만 하면 된다.
    N -= 1
    sum += 1

print(sum)

# 1씩 빼는것보다 무조건 나누는게 좋다. N이 K보다 크거나 같으면 최대한 나누기를 수행하고 남은 만큼 빼기를 수행하면 된다.


# 2. 곱하기 혹은 더하기
# 입력 조건
# 첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어집니다. (1<= S의 길이 <= 20)

# 출력 조건
# 첫째 줄에 만들어질 수 있는 가장 큰 수를 출력합니다.

a = input()
b = list(a)
i=0
sum = int(b[i])

for i in range(len(b)):
    if i != len(b)-1:
        if sum <= 1 or int(b[i+1]) <= 1:
            sum += int(b[i + 1])
        else:
            sum *= int(b[i + 1])
print(sum)

# 0과 1만 아니면 곱하는게 무조건 좋다.

# 3. 모험가 길드 (혼자 해결 못 한 문제 재풀이 필요)
# 입력조건
# 첫째 줄에 모험가의 수 N이 주어집니다. (1 <= N <= 1000,000)
# 둘째 줄에 각 모험가의 공포도의 값을 N 이하의 자연수로 주어지며, 각 자연수는 공백으로 구분

# 출력 조건
# 여행을 떠날 수 있는 그룹 수의 최댓값을 출력합니다.

N = int(input())
fear = list(map(int, input().split()))
fear.sort() # 오름차순으로 정렬해서 보내면 더 많이 보내기 가능

group = 0 # 그룹 수
count = 0 # 현재 그룹 모험자 수 초기화 필요

for i in fear:
    count += 1
    if count >= i:
        group += 1
        count = 0
print(group)